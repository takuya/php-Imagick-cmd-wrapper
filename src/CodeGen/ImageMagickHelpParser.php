<?php

namespace CodeGen;

use Illuminate\Support\Str;
use Nette\PhpGenerator\ClassType;

class ImageMagickHelpParser {

  protected function add_phpdoc_to_service_class_docblock($command, $methods){
    $class_name = ucfirst($command);
    $target = "class Convert";
  }
  
  
  protected static function getHelp($cmd){
    $ret = `${cmd}`;
    return $ret;
  }
  protected static function parseOptions($help_string){
    $lines = preg_split( '/\n/', $help_string );
    $ret = [];
    foreach ($lines as $idx => $line) {
      if ( !preg_match( '/^\s{2}-[A-z]/', $line ) ) {
        continue;
      }
      for ( $k=1;$k<5;$k++){
        $next = $lines[$idx+$k] ?? '';
        if ( preg_match('/(^\s{2}-[A-z])|(^[A-z])/',$next) ){
          break;
        }
        $next= preg_replace('/^\s+/', ' ', $next);
        $line = $line."\n".$next;
      }
      $ret[]=$line;
    }
  
    //dd($ret);
    $ret = collect( $ret )
      //->filter( function( $e ) { return preg_match( '/-[a-z]+/', $e ); } )
      ->map(function($e){
        $s22 = substr($e,21,1);
        $s23 = substr($e,22,1);
        $s24 = substr($e,23,1);

        //printf("%s%s%s  %s\n",
        //  str_replace( ["\r", "\n"], "\\n", $s22 ),
        //  str_replace( ["\r", "\n"], "\\n", $s23 ),
        //  str_replace( ["\r", "\n"], "\\n", $s24 ),
        //  str_replace( ["\r", "\n"], "\\n", $e ));
        
        if ( !preg_match('/\n/', $e ) && $s23 == " " && $s22 != ' ' ){
          $e[22]="\n";
        }
        
        if( preg_match('/\n/', $e)) {
          $a = preg_split('/\n/',$e,2)[0];
          $b = preg_split('/\n/',$e,2)[1];
          preg_match( '/\s?-([-\w]+)\s?([":,\w]*\s?[":,\w]*)/', $a, $m );
          $m[3] = trim( str_replace("\n", " ",$b));
          $m["-1"] = $e;
          return $m;
        }else{
          preg_match('/\s?-([-\w]+)\s([":,\w]*\s?[":,\w]*)[\s\r\n]*(.*)/', $e, $m);
          $m["-1"] = $e;
          return $m;
        }
      })
      ->map(function($e){
        $v =  [
          "name" => $e[1],
          "args"  => $e[2]??null,
          "comm" => $e[3]??null,
          "orig" => $e["-1"]
        ];
        return collect($v)->map(function($e){return trim($e);})->toArray();
      })
      ->toArray();
    //var_dump(collect($ret)->filter(function($e){
    //  return in_array($e['name'],['annotate','define','type']) ;}));
  
    //foreach ( $ret as $idx =>$e ) {
    //  printf( "% 3d %-25s  %-20s %-50s\n", $idx+1,...array_values($e));
    //}
    return $ret;
    
  }
  protected static function option_to_method_definition($opts){
    $methods = collect($opts)->map(function($e){
      $e['args'] = collect(preg_split('/\s+/',$e['args']))->reject(function($s){ return empty($s); })->toArray();
      $e['comm'] = $e['comm'] ? ucfirst($e['comm']).'.':'';
      $e['name'] = Str::camel($e['name']);
      unset($e['orig']);
      return $e;
    })->keyBy('name')->toArray();
    
    return $methods;
  }
  public static function createClassFromHelp($cmd){
    static::parse($cmd);
  }
  protected static function parse($command){
    $help_string = static::getHelp($command);
    $opts = static::parseOptions($help_string);
    $methods = static::option_to_method_definition($opts);
    $src = static::create_class_source($command,$methods);
    $out_file = static::generate_class_file($command,$src);
    static::add_phpdoc_to_service_class_docblock($command,$methods);
    
    echo "generated {$out_file}\n";
  }
  protected static function generate_class_file($command, $src){
    $class_name =  ucfirst( Str::camel($command) );
    $out_file = __DIR__."/../generated/AutoGeneratedTraits/${class_name}Generated.php";
    file_put_contents($out_file , $src);
    $out_file = realpath($out_file);
    return $out_file;
  }
  protected static function create_class_source( $command, $method_defs){
    
    $class_name =  ucfirst( Str::camel($command) );
    $class = new \Nette\PhpGenerator\ClassType($class_name.'Generated');
    $class->setType(ClassType::TYPE_TRAIT);
    $class->addComment("Auto generated from '$command -h' help");
  
    foreach ( $method_defs as $e ) {
      $name = $e['name'];
      $comm = $e['comm'];
      $args = $e['args'];
      $method = $class->addMethod($name);
      $method->addComment($comm);
      // parameter
      if (sizeof( $args ) > 0 ) {
        foreach ( $args as $arg ) {
          $escaped_arg_name = preg_replace( '/\W/', '_', $arg );
          $method->addParameter( $escaped_arg_name );
          $parameter_comment_doc = "@param \$${escaped_arg_name} string ".(preg_match('/\W/',$arg)?"'$arg'":ucfirst($arg));
          $method->addComment( $parameter_comment_doc );
        }
        $arg_names = collect( $args )->map( function( $arg_name ) {
          $arg_name = preg_replace( '/\W/', '_', $arg_name );
          return "\${$arg_name}";
        } )->join( '." ".' );
        $method_body = "return \$this->addOpt('-${name}', $arg_names );";
        $method->addBody( $method_body );
      }else{
        $method->addBody( "return \$this->addOpt('-{$name}');" );
      }
    }
  
    $prefix = "<?php\n\n";
    $src = $prefix.$class->__toString();
    
    $class->addProperty('command_path', $command);
    return $src;
  }
}